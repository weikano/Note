### 2.1 三次握手
> ![image](https://raw.githubusercontent.com/weikano/NoteResources/master/WEB-Guide/1.png)
> - SYN：客户端选择一个随机序号x，并发送一个SYN分组，其中可能还包括其他的TCP标志和选项
> - SYN ACT：服务器给x加1，并选择自己的一个随机序号y，追加自己的标志和选项，返回响应
> - ACK：客户端给x和y加1并发送握手期间最后一个ACK分组
> 
> 客户端可以在发送ACK分组后立即发送数据，而服务器端只能在接收到ACK分组后才能发送数据

### 2.2 拥塞预防及控制
#### 2.2.1 流量控制
> ![image](https://raw.githubusercontent.com/weikano/NoteResources/master/WEB-Guide/2.png)
> 
> TCP连接的每一方都需要通告自己的接收窗口，其中包含能够保存数据的缓冲空间的大小

#### 2.2.2 慢启动
> 假设纽约的客户端需要通过TCP连接到伦敦的服务器请求一个20kb的文件，下面是连接的参数：
> - 往返时间56ms
> - 客户端到服务器的带宽：5Mbit/s
> - 客户端和服务器接收窗口：65535bits = 64KB
> - 初始的拥塞窗口：4段(4x1460bit) = 5.7KB
> - 服务器生成响应的时间：40ms
> - 没有分组丢失、每个分组都要确认、GET请求只占一段
>
> ![image](https://raw.githubusercontent.com/weikano/NoteResources/master/WEB-Guide/3.png)
>
> 重用同一个TCP连接，再发送一次相同的请求，因为窗口大小已经大于发送文件所需要的15段(20480字节)了，所以一次就可以发送完成。不需要三次握手和慢启动，只花了96ms

#### 2.2.3 拥塞预防
> 拥塞预防算法把丢包作为网络拥塞的标志，必须调整窗口大小以避免造成更多的包丢失

### 2.3 带宽延迟积
### 2.4 队首阻塞
> 每个 TCP 分组都会带着一个唯一的序列号被发出，而所有分组必须按顺序传送到接收端。如果中途有一个分组没能到达接收端，那么后续分组必须保存在接收端的 TCP 缓冲区，等待丢失的分组重发并到达接收端

### 2.5 针对TCP的优化建议
> - TCP三次握手增加了整整一次往返时间
> - TCP慢启动将被应用到每个新连接
> - TCP流量及拥塞控制会影响每个连接的吞吐量
> - TCP的吞吐量由当前拥塞窗口大小控制

#### 2.5.1 服务器配置调优
> - 增大TCP的初始拥塞窗口
> - 慢启动重启禁用
> - 启用窗口缩放
> - 启用TCP快速打开

#### 2.5.2 应用程序调优
> - 再快也快不过什么都不发
> - 缩短传输距离
> - 重用TCP连接

#### 2.5.3 性能检查清单
> - 升级服务器内核
> - 禁用TCP慢启动
> - 确保启动窗口缩放
> - 减少传输冗余数据
> - 压缩要传输的数据
> - 服务器距离缩短
> - 重用TCP连接
