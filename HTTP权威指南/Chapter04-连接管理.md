### 4.2 对TCP性能的考虑
#### 4.2.1 HTTP事务的时延
> ![image](https://raw.githubusercontent.com/weikano/NoteResources/master/HTTP-Guide/1.png)
> 1. DNS解析
> 2. TCP连接建立需要3次握手
> 3. 客户端发送请求、服务器读取请求并处理
> 4. 服务器返回http响应

#### 4.2.2 性能聚焦区域
> 1. TCP建立握手
> 2. TCP慢启动拥塞控制
> 3. 数据聚焦的Nagle算法
> 4. 用于捎带确认的TCP延迟确认算法
> 5. TIME_AWAIT时延和端口耗尽

#### 4.2.3 TCP连接的握手时延
> ![image](https://raw.githubusercontent.com/weikano/NoteResources/master/HTTP-Guide/2.png)
> 1. 请求新的TCP连接时，客户端向服务器发送一个小的TCP分组（40~60字节）。设置了一个特殊的SYN标志，表明这是一个连接请求
> 2. 服务器接受了连接，就会对一些连接参数进行计算，并向客户端返回一个TCP分组，其中SYN和ACK标记会被置位，说明连接请求已被接受
> 3. 客户端向服务器回送一条确认消息，通知它连接已成功建立

#### 4.2.4 延迟确认
> 每个TCP段都有一个序列号和数据完整性校验和。每个段的接收者收到完整的段时，都会向发送者回送小的确认分组。如果发送者没有在指定的窗口时间内收到确认消息，发送者就认为分组已被破坏或毁坏，并重发数据
>
> 由于确认报文很小，所以一般在发往相同方向的输出数据分组中对其进行捎带。
>
> 延迟确认算法会在一个特定的窗口时间内将输出确认放在缓冲区，以寻找能够捎带它的输出数据分组

#### 4.2.5 TCP慢启动
> TCP慢启动限制了一个TCP端点在任意时刻可以传送的分组数。简单来说，每成功发送一个分组，发送端就有了发送另外两个分组的权限。因此，新连接的传输速度会比已经交换过一些数据的连接慢（HTTP 持久连接， Socket长连接）

#### 4.2.6 Nagle算法与TCP_NODELAY
> TCP是一个数据流，它允许将任意尺寸的数据放入TCP栈中，即使一个字节。但是每个TCP端中至少装在了40~60字节的标记和首部，所以如果TCP发送了大量包含少量数据的分组，性能会严重影响（发送端傻端口综合征）。
>
> Nagle算法试图将大量数据绑定在一起发送，以提高效率。Nagle鼓励发送全尺寸的段。只有当其他所有分组的都确认之后，Nagle才允许发送非全尺寸的分组。缺点：小的http报文可能无法填补一个完整分组，导致等待其他数据；延迟确认算法与Nagle存在交互问题。
>
> TCP_NODELAY可以禁止Nagle算法

#### 4.2.7 TIME_WAIT累积和端口耗尽
> 当某个TCP端点关闭TCP连接时，会在内存中维护一个小的控制块，用来记录最近关闭的IP和端口号，以确保在这段时间内不会创建具有相同IP和端口号的新连接（时间通常为2MSL）
>
> 由于端口号是有限的（比如60000），并且在2MSL秒内连接无法重用，连接率就被限制在60000/2MSL，如果2MSL为120秒，那么就只能由500连接/秒。

### 4.3 HTTP连接处理
##### 4.3.1 Connection首部
> Connection首部可以承载3种不同类型的标签
> - HTTP首部字段名，列出了只与此连接有关的首部
> - 任意标签值，用于描述此连接的非标准选项
> - 值close，说明操作完成之后需要关闭这条连接
> 
> Connection中的首部字段不允许转发出去，比如Connection:Accept-Language，那么转发后的请求首部就会移除掉原请求首部中的Accept-Language

#### 4.3.2 串行事务处理时延
> 解决方案：
> - 并行连接：通过多条TCP连接发起并发的HTTP请求
> - 持久连接：重用TCP连接，以消除建立连接及关闭的时延
> - 管道化连接：通过共享的TCP连接发起并发的HTTP请求

### 4.4. 并行连接
#### 4.4.1 并行连接可能会提高页面的加载速度
> ![image](https://raw.githubusercontent.com/weikano/NoteResources/master/HTTP-Guide/3.png)
#### 4.4.2 并行连接不一定更快
> - 客户端带宽。如果并行加载多个对象，每个对象都会去竞争有限的带宽，每个对象都会以较慢的速度按比例加载，这样性能提升就很小。
> - 大量连接会消耗很多内存资源。
> - 当前浏览器使用了并行连接，但连接总数限制为(2-8)个？
> - 每个事务都会打开/关闭一个新的连接，耗时和带宽
> - TCP慢启动，新连接性能不足
> - 可打开的并行连接数量有限
#### 4.4.3 并行连接感觉更快一点

### 4.5 持久连接
#### 4.5.1 持久以及并行连接
> 持久连接降低了时延和连接建立的开销，将连接状态保持在已调谐，跳过了慢启动。持久连接+并行连接可能是最高效的方式。

#### 4.5.2 HTTP/1.0+keep-alive连接
> 请求头中包含Connection: Keep-Alive。如果服务器允许持久连接，就会在响应头中包含Connection: Keep-Alive首部，否则客户端就会认为服务器不支持，会在发回响应报文后关闭连接
#### 4.5.3 keep-alive操作
#### 4.5.4 Keep-Alive选项
> Connection: Keep-Alive
>
> Keep-Alive: max=5, timeout=120
>
> - timeout参数：Keep-Alive响应首部发送。估计了服务器希望维持连接的时长。不是承诺值
> - max：Keep-Alive响应首部发送。估计了服务器还希望为多少事务保持此连接的活跃状态，不是承诺值

#### 4.5.6 Keep-Alive和哑代理
> 所有代理都不能转发Connection首部和所有名字出现在Connection值中的首部。
#### 4.5.7 插入Proxy-Connection
#### 4.5.8 HTTP/1.1持久代理
> 默认激活持久代理，要关闭持久代理，需要在报文中显示添加Connection: close首部。
#### 4.5.9 持久连接的限制和规则
> - 发送了Connection: close之后，客户端无法在那条连接上发送更多的请求
> - 如果客户端不想在连接上发送更多数据，就应该在最后一条请求中发送一个Connection: close首部
> - 只有当连接上所有的报文都有正确的自定义的报文长度时（Content-Length），连接才能持久保持

### 4.6 管道化连接
> ![image](https://raw.githubusercontent.com/weikano/NoteResources/master/HTTP-Guide/4.png)
> 管道化连接的限制：
> - 必须支持持久化
> - 必须按照与请求相同的顺序返回HTTP响应，应为HTTP报文中没有序列号，如果失序就没法将请求与响应匹配起来
> - 客户端必须做好连接会在任意时刻关闭的准备。比如发送了10条请求，但服务器在处理了5条请求后就关闭了连接
> - 客户端不应该用管道化的方式发送会产生副作用的请求，比如POST。

### 4.7 关闭连接的奥秘
#### 4.7.1 任意解除连接
#### 4.7.2 Content-Length及截尾操作
> 每条响应都应该由一个准确的Content-Length首部，用来描述主体的尺寸
#### 4.7.3 连接关闭容限、重试以及幂等性
#### 4.7.4 正常关闭连接
1. 完全关闭和半关闭
> 应用程序可以关闭TCP输入和输出的任意一个，或者将两者都关闭。
2. TCP关闭与重置错误
3. 正常关闭