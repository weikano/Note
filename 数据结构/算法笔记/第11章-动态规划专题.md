### 第11章-动态规划专题

#### 11.1 动态规划的递归写法和递推手法

##### 11.1.1 什么是动态规划

动态规划（dynamic programming，DP）是一种用来解决一类最优化问题的算法思想。

动态规划将一个问题划分为若干个子问题，通过综合子问题的最优解来得到原问题的最优解。动态规划会将每个求结果的子问题的最优解记录下来。

一般使用递归或者递推的写法来实现动态规划，其中递归写法又称为记忆化搜索

##### 11.1.2 递归写法

```c++
int dp[MAXN] = {-1};

int fib(int n) {
  if(n == 0 || n==1) return 1;
  if(dp[n] != -1) {
    return dp[n];
  }
  dp[n] = fib(n-1) + fib(n-2);
  return dp[n];
}
```

**重叠子问题：如果一个问题可以被分为若干子问题，这些子问题会重复出现，那么表示这个问题拥有重叠子问题**

**一个问题必须拥有重叠子问题，才能使用DP去解决**。

##### 11.1.3 递推写法

经典的数塔问题为例。将一些数字摆放为数塔的形式，第一层有一个数字，第2层有两个数字，第n层有n个数字。现在要从第一层走到最后一层，每次只能选择走向下一层连接的两个数字中的一个，求所有数字相加的最大值。

令f\[i][j]表示第i层的第j个数字，假设第一层为5，第二层为8和3，那么f\[1][1]=5, f\[2][1]=8, f\[2][2]=3。

**令dp\[i][j]表示从第i行第j个数字出发的到达最底层的最大和，那么dp\[i][j]=max(dp\[i+1][j], dp\[i+1][j+1]) + f\[i][j]**。

把dp\[i][j]称为问题的状态，把上面的式子称为状态转移方程，它把dp\[i][j]转移到dp\[i+1][j]和dp\[i+1][j+1]。即状态dp\[i][j]只与第i+1层的状态有关，与其他层的状态无关，这样层号为i的状态总可以表示为层号为i+1的两个子状态得到

```c++
int f[MAXN][MAXN];
int dp[MAXN][MAXN];

int main() {
  int n;//层数
  //输入数塔到数组f
  //边界
  for(int j=1;j<=n;j++) {
    dp[n][j] = f[n][j];
  }
  //从第n-1层往上计算dp[i][j]
  for(int i=n-1;i>=1;i--) {
    for(int j=1;j<=i;j++) {
      dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + f[i][j];
    }
  }
  printf("%d\n", dp[1][1]);
  return 0;
}
```

递推法是由下往上，从边界开始不断向上解决问题；递归法是由上往下，从目标问题开始将他分解为子问题的组合，直到边界为止。

最优子结构：如果一个问题的最优解可以由其子问题的最优解有效的构造出来，那么称这个问题拥有最优子结构。**一个问题必须拥有最优子结构和重叠子问题，才能使用DP解决**

- 分治和动态规划：分治法分解出来的子问题是不重叠的，比如归并和快速排序，都是分别处理左序列和右序列，然后将左右序列合并，过程中不出现重叠子问题。分治法解决的不一定是最优化问题，动态规划解决的问题一定是最优化问题
- 贪心和动态规划：二者都要求原问题必须拥有最优子结构。二者的却别在于，**贪心法使用的计算方式类似于上面介绍的自顶向下，但是并不等待子问题求解完毕后再选择使用哪一个，而是通过某种策略直接选择一个子问题求解，没被选择的子问题直接抛弃。即只在上一步选择的基础上继续选择，因此就数塔问题，贪心法从最上层开始，每次都选择左下和右下两个数字较大的一个，一致到最底层得到结果，不一定是最优解**。

#### 11.2 最大连续子序列和

> 给定一个数字序列A[n], 是使得A[i]+…+A[j]最大的值

思路：暴力法获取遍历i和j，然后求和A[i]+…+A[j]，复杂度O(n^3)。下面以DP来求解，以-2,11,-4,13,-5,-2为例

1. 令dp[i]为以A[i]结尾的最大子序列的和，则有dp[0]=-2,dp[1]=-2+11=9,dp[2]=11-4=7,dp[3]=11-4+13=20……，也就是说最大子序列的和其实就是max(dp[i])。

2. 因为dp[i]是以元素A[i]为结尾的，那么就存在两种情况：

   A. 最大和只包含最后A[i]

   B. 最大和有多个元素，从p到i为止，那么可以写成dp[i]=dp[i-1]+A[i]

3. 由上面两步可知, dp[i]=max(A[i], dp[i-1] + A[i]);

```c++
int maxsub() {
  dp[0] = A[0];
  for(int i=1;i<n;i++) {
    dp[i] = max(dp[i-1]+A[i], A[i]);
  }
  int max_s = 0;
  for(auto const m : dp) {
    max_s = max(max_s, m);
  }
  return max_x;
}
```

状态的无后效性：当前状态记录了历史信息，一旦当前状态确定，就不会再改变，且未来的决策只能在已有的一个或若干个状态的基础上进行，历史信息只能通过已有的状态去影响未来的决策。例如上述的dp[i]，都只会涉及到dp[i-1]，没有直接用到dp[i-1]蕴含的历史信息。

**对动态规划可解的问题来说，必须设计一个拥有无后效性的状态以及相应的状态转移方程，否则动态规划就无法得到正确结果**。

#### 11.4 最长不下降子序列（LIS）

> 在一个数字序列中，找到一个最长的子序列（可以不连续），使得这个子序列是非递减的

令dp[i]表示以A[i]结尾的最长不下降子序列长度，这样就有两种可能：

1. 如果存在1A[i]之前的元素A[j]，使得A[j]<=A[i]并且d[j]+1>dp[i]（即把A[i]跟在以A[j]结尾的LIS后面时，能比以当前A[i]结尾的LIS长度更长），那么就把A[i]跟在以A[j]结尾的LIS后面，形成一条更长的LIS，即dp[i]=dp[j]+1
2. 如果A[i]之前的元素都比A[i]大，那么A[i]就只好自己形成一条LIS，即dp[i]=1

最后，以A[i]结尾的LIS长度就是1、2中的最大值

以1,5,-1,3为例，有dp[0]=1, dp[1]=2, dp[2]=2,dp[3]=2

状态转移方程：dp[i]=max(1, dp[j]+1)，其中(j=0…i-1 && A[j]<A[i])

显然dp[i]只与小于i的j有关，因此只要让i从小到大遍历即可求出整个dp。由于dp[i]表示的是以A[i]结尾的LIS长度，因此从整个dp数组中找出最大的那个才是要寻求的整个序列的LIS长度，复杂度为O(n^2)

```c++
int LIS(int A[], int n) {
  int ans = -1;//记录最大的dp[i]
  for(int i=0;i<n;i++) {
    dp[i] = 1;//边界初始条件（假设每个元素自成一个子序列)
    for(int j=0;j<i;j++) {
      if(A[i] >= A[j] && dp[J]+1 > dp[i]) {
        dp[i] = dp[j]+1;
      }
    }
    ans = max(ans, dp[i]);
  }
  return ans;
}
```

#### 11.4 最长公共子序列（LCS）

> 跟定两个字符串或数组序列A、B，求一个字符串，使得这个字符串是A和B的最长公共部分，可以不连续

比如“sadstory”和“adminsorry”的最长公共子序列为“adsory”

令dp\[i][j]表示字符串A的i号位和字符串B的j号位之前的LCS长度，dp\[4][5]表示“sads”与“admin”的LCS长度，那么根据A[i]和B[j]的情况：

1. 若A[i]=B[j]，那么字符串A和字符串B的LCS增加一位，dp\[i][j]=dp\[i-1][j-1]+1。
2. 若A[i]!=B[j]，那么dp\[i][j] = max(dp[i-1]d[j], dp\[i][j-1])

**边界条件**：dp\[i][0]=dp\[0][j] = 0;

**状态转移方程**：
$$
dp[i][j]=\begin{cases}
dp[i-1][j-1]+1 & A[i]=B[j] \\
max(dp[i-1][j],dp[i][j-1]) & A[i]!=B[j]
\end{cases}
$$

```c++
int LCS(const string& A, const string& B) {
  size_t lenA = A.size();
  size_t lenB = B.size();
  int N = 100;
  dp[N][N] = {0};
  for(int i=0;i<lenA;i++) {
    dp[i][0] = 0;
  }
  for(int j=0;j<lenB;j++) {
    dp[0][j] = 0;
  }
  for(int i=0;i<lenA;i++) {
    for(int j=0;j<lenB;j++) {
      if(A[i] == B[j]) {
        dp[i][j] = dp[i-1][j-1]+1;
      }else {
        dp[i][j] = max(dp[i][j-1], dp[j][i-1]);
      }
    }
  }
 	return dp[lenA-1][lenB-1];
}
```

#### 11.5 最长回文子串*

> 给出一个字符串S，求S的最长回文子串的长度

样例：PATZJUJZTACCBCC

暴力法：枚举两个端点n*n，判断两个端点之间是否回文n，即复杂度为O(n^3)

DP法：令dp\[i][j]为S[i]至S[j]所表示的子串是否回文子串，是则为1，不是为0。这样根据S[i]是否等于S[j]，可以把情况转移为两类。

1. S[i]=S[j]，那么只要S[i+1]至S[i-1]为回文串，S[i]至S[j]就是回文串；如果S[i+1]至S[j-1]不是回文串，那么S[i]至S[j]也不是回文串
2. S[i]!=S[j]，那么S[i]至S[j]一定不是回文串

由此有**状态转移方程**：
$$
dp[i][j]=\begin{cases}
dp[i+1][j-1], & S[i]==S[j] \\
0, & S[i] != S[j]
\end{cases}
$$
**边界情况**：dp\[i][i]=1, dp\[i][i+1]=(S\[i]==S[i+1]?1:0)（长度为1和2的子串）

这里还有一个问题没有解决，那就是如果按照i和j从小到大的顺序来枚举子串的两个端点，然后更新dp\[i][j]，会无法保证dp\[i+1][j-1]已经被计算过，从而无法得到正确的dp\[i][j]。

因此不能直接通过端点来，而是通过子串长度

```c++
int calc(const string& A) {
  size_t len = A.size();
  int ans = 1;
  const int N = 100;
  int dp[N][N] = {0};
  for(int i=0;i<len;i++) {
    dp[i][i]=1;
    if(i < len -1) {
      if(A[i] == A[i+1]) {
        dp[i][i+1]=1;
        ans = 2;
      }
    }
  }
  
  for(int L=3;L<=len;L++) {//遍历子串长度
    for(int i=0;i+L-1<len;i++) {//枚举子串长度的起始端点
      int j = i+L - 1;//子串的终点
      if(A[i] == A[j] && dp[i+1][j-1] == 1) {
        dp[i][j] = 1;
        ans = L;
      }
    }
  }
  return ans;
}
```

#### 11.6 DAG最长路（边权之和最大*）

着重解决两个问题：

1. 求整个DAG中的最长路径（不固定起点跟终点）
2. 固定终点，求DAG最长路径

**1. DAG的最长路径**

令dp[i]表示从i号顶点出发能获得的最长路径长度，这样max(dp[i])即为整个DAG的最长路径长度。如果从i号顶点能直接到达j~1~,j~2~,…j~k~，而dp[j~1~],dp[j~2~],…,dp[j~k~]均已知，那么就有dp[i]=max(dp[j~m~])+length[i->j]。

显然根据上面的思路，需要按照逆拓扑序列的顺序来求解dp数组，但是也可以通过递归的方式来解决

```c++
int DP(int i) {
  //用二维数组的方式保存G(V,E)，未连接的边的G[i][j]=INF
  if(dp[i]>0) return dp[i];
  for(int j=0;j<n;j++) {//遍历i所有边
    if(G[i][j] != INF) {
      dp[i]=max(dp[i], DP[j]+G[i][j]);
    }
  }
  return dp[i];
}
```

如何获得最长路径呢

```c++
int DP(int i) {
  if(dp[i]>0) return dp[i];
  for(int j=0;j<n;j++) {
    if(G[i][j] != INF) {
      int temp = DP(j)+G[i][j];
      if(temp>dp[i]) {
        dp[i] = temp;
        choice[i] = j;//i号顶点的后继点是j
      }
    }
  }
  return dp[i];
}

void printPath(int i) {
  printf("%d", i);
  while(choice[i] != -1) {//choice数组初始化为-1
    i = choice[i];
    printf("->%d", i);
  }
}
```

**2. 固定终点的DAG最长路径**

假设终点为T，令dp[i]表示从I号顶点出发到达终点T能获得的最长路径长度。如果从i号顶点能直接到达j~k~，而且dp[j~k~]已知，那么就有dp[i]=max(dp[j~k~]) + length(i->j);

跟第一个问题的区别在于边界不同。第一个问题没有固定终点，那么出度为0的顶点的dp值为0是边界。但是这个问题固定了终点，所以dp[T]=0。因为可能从某些顶点无法到达T，比如出度为0的顶点，所以合适的做法是初始化dp数组为一个符的大数，来保证“无法到达终点”(-INF)的含义得以表达，然后设置一个vis数组表示顶点是否已被计算过。

```c++
int DP(int i) {
  if(vis[i]) return dp[i];//dp[i]已被计算
  vis[i] = true;
  for(int j=0;j<n;j++) {
    if(G[i][j] != INF) {
      dp[i]=max(DP[j]+G[i][j], dp[i]);
    }
  }
  return dp[i];
}
```

#### 11.7 背包问题

##### 11.7.1 多阶段动态规划问题

##### 11.7.2 01背包问题

> 有n件物品，物品的重量为w[i]，价值为c[i]。现有一个容量为v的背包。问如何选取物品放入背包，使得总价值最大。每件物品数量为1.

暴力法：枚举每件物品放入或者不放入，复杂度为O(2^n)

动态规划：令dp\[i][v]表示当前i件物品恰好装入容量v的背包中能获得的最大价值。考虑对第i件物品的选择策略：

1. 不放第i件物品，那么问题转化为前i-1件物品敲好装入容量为v的背包中所能获得的最大价值dp\[i-1][v]
2. 放入第i件物品，那么转化为前i-1件物品恰好装入前v-w[i]容量的背包中能获得的最大价值dp\[i-1][v-w[i]]

**状态转移方程**：dp\[i][v]=max(dp\[i-1][v], dp\[i-1][v-w[i]])

**边界条件**：dp\[0][v]=0，即前0件物品放入任何容量的背包中都只能获得价值0

```c++
int maxVal() {
  int maxV = 0;
  for(int i=1;i<=n;i++) {
    for(int v=w[i];v<=V;v++) {
      dp[i][v]=max(dp[i-1][v], dp[i-1][v-w[i]] + c[i]);
      maxV = max(maxV, dp[i][v]);
    }
  }
  
}
//空间优化版
int maxVal() {
  //边界
  for(int v=0;v<=V;v++) {
    dp[v]=0;
  }
  for(int i=1;i<=n;i++) {
    for(int v=V;v>0;v--) {
      dp[v]=max(dp[v], dp[v-w[i]]+c[i]);
    }
  }
  int maxV = 0;
  for(int v=0;v<=V;v++) {
    maxV = max(maxV, dp[v]); 
  }
  return maxV;
}
```

##### 11.7.3 完全背包问题

> 有n中物品，每种物品的单件重量为w[i]，价值为c[i]。现有一个容量为V的背包，问如何选择放入的，使得背包中物品的总价值最大。其中每件物品都有无数个。

令dp\[i][v]表示前i件物品恰好放入容量v的背包中能获得的最大价值：

1. 不放入第i件物品，dp\[i][v]=dp\[i-1][v]
2. 放入第i件物品。因为每种物品可以放入任意数量，只有容量限制，因此转移至dp\[i][v-w[i]]，即放入了第i件物品还可以继续放入第i件物品，直到v-w[i]无法保持大于等于0为止

**状态转移方程**
$$
dp[i][v]=max(dp[i-1][v], dp[i][v-w[i]]+c[i])，
(1\leq i \leq n, w[i] \leq v \leq V)
$$
**边界**：dp\[0][v] = 0

可以优化状态转移方程可以写成一维形式
$$
dp[v]=max(dp[v], dp[v-w[i]]+c[i])，
(1\leq i \leq n, w[i] \leq v \leq V)
$$
边界：dp[v]=0

```c++
for(int i=1;i<=n;i++) {
  for(int v=w[i];v<V;v++) {
    dp[v]=max(dp[v], dp[v-w[i]]+c[i]);
  }
}
```

#### 11.8 总结

1. 最大连续子序列之和：令dp[i]表示以A[i]元素结尾的最大和
2. 最长不下降子序列（LIS）：令dp[i]表示以A[i]元素结尾的最长不下降子序列的长度
3. 最长公共子序列（LCS）：令dp\[i][j]表示A[i]和B[j]的最长LCS的长度
4. 最长回文字符串：令dp\[i][j]表示A[i]到A[j]的是否回文串
5. 数塔DP：令dp\[i][j]表示从第i行j个数字出发，到达最底层的所有路径中所能得到的最大和
6. DAG最长路：dp[i]表示从i号顶点出发能获得的最长路径长度
7. 01背包：dp\[i][v]表示前i件物品敲好装入容量v的背包中能获得的最大价值
8. 完全背包：dp\[i][v]表示前i件物品敲好装入容量v的背包中能获得的最大价值

特别说明：一般来说，子序列可以不连续，而子串一定要连续

**当题目与序列或字符串（记为A）有关时，可以考虑把状态设计成下面两种形式**：

1. 令dp[i]表示以A[I]结尾（或开头）的XXX。
2. 令dp\[i][j]表示以A[i]开头A[j]结尾的XXX。

其中XXX均为原问题的表述

**DP问题的状态设计方法**：

分析题目中的状态需要几维表示，然后对其中的每一维采取下面的某一个表述：

1. 恰好为i
2. 前i

在每一维的含义设置完毕后，dp数组的含义就可以设置为“令dp数组表示恰好为i（或前i）、恰好为j（或前j）……的XXX”，其中XXX为原问题的表述。接下来可以通过端点的特点去考虑状态转移方程。