### 第13章-专题扩展

#### 13.1 分块思想

- 在线查询：如果在查询的过程中，元素可能会发生改变（插入、修改或删除）。
- 离线查询：查询过程中元素不改变

问题：给出一个非负整数序列，元素个数为N，元素不超过10^5^，在有可能随时添加或删除元素的情况下，实时查询序列元素的第K大，即把序列排序后第K个元素

思路：暴力做法，在添加和删除元素后就要有O(n)的时间复杂度来移动序列的元素。**可以采用分块的思想**

把有序元素分为若干块。比如拥有9个元素的有序序列，可以分为3块。一般来说，为了达到高效率的目的，对一个有N个元素的有序序列来说，除最后一块之外，每块中元素的个数应当为$\sqrt n$，于是块数也为$\sqrt n$。

设置一个hash数组table[10001]，其中table[x]表示x的当前存在个数；接着借助分块的思想，从逻辑上将0->10^5分为$\sqrt {10^5+1}$块，即317块。

这样可以定义一个统计数组block[317]，其中block[i]表示第i块中存在的元素个数。于是假设要新增一个元素x，可以计算出x所在的块号为x/316，然后让block[x/316]加1，表示该块中元素多了1；同时令table[x]加1，表示整数x的当前存在个数多了1。

**例如要新增344这个元素，block[1]++，table[334]++；同理要删除，只要减1即可。显然，新增和删除元素的复杂度都为O(1)**

如何查询序列中第K大的元素呢？

首先，从小到大枚举块号，利用block数组累加得到前i-1块中存在的元素个数，然后判断加入i号块周的元素个数总数能否达到K。

如果能，说明K在i块中，此时只需从小到达遍历该快中的每个元素（其中i号块的第一个元素是i*316，利用table数组继续累加元素存在的个数，直到总累计数到达K，说明找到了序列第K大的树。

#### 13.2 树状数组

##### 13.2.1 lowbit运算

lowbit(x) = x & (-x)，可以理解为x在二进制表示下，最低位的1及其后面所有的0构成的数值

比如10的二进制为1010，lowbit(10)=(10)~2~=2

##### 13.2.2 树状数组及其应用

给出一个整数序列A，元素个数为N($N \leq 10^5$)，接下来查询K次($K \leq 10^5$)，每次查询将给出一个正整数x(x<=N)，求前n个正整数之和。例如对5个整数2,4,1,5,3，如果查询前3个整数之和，就需要输出7；如果查询前5个整数之和，那么就输出15。

树状数组BIT是一个用来记录和的数组，只不过它存放的不是前i个整数之和，而是在i号位之前lowbit(i)个整数之和（包含i）。

数组A是原始数组，一共有16个元素，下标从1开始。假设数组C是树状数组，那么C[1]存放的是第1个元素前lowbit(1)=1个元素，即A[1]，C[2]存放的是第2个元素之前lowbit(2)=2个元素之和，即A[1]+A[2]，同理C[3]表示的是A[3]元素之前lowbit(3)=1个元素之和，即A[3]

**此处强调，树状数组的定义非常重要，特别是“C[i]的覆盖长度是lowbit(i)”这点；另外树状数组的下标必须从1开始，务必注意**。

**接下来有两个问题**：

1. 怎样设计getSum(x)，返回前x个数之和
2. 设计函数update(x,v)，实现将第x个数加上v，即A[x]+=v

**第一个问题**

因为C[x]覆盖的长度为lowbit(x)，即$C[x]=A[x-lowbit(x)+1]+\cdots+A[x]$

于是有可以得出$SUM(1,x)$的公式为：
$$
\begin{equation}\begin{split} SUM(1,x)
&=A[1]+\cdots+A[x]\\
&=A[1]+\cdots+A[x-lowbit(x)]+A[x-lowbit(x)+1]+\cdots+A[x]\\
&=SUM(1,x-lowbit(x))+C[x]
\end{split}\end{equation}
$$
因此可以写出getSum函数

```c++
int getSum(int x) {
  int sum = 0;
  for(int i=x;i>0;i-=lowbit(i)) {
    sum += c[i];
  }
  return sum;
}
```

**第二个问题**

想要给A[x]加上V，就要更改树状数组C中覆盖到x的元素。那么怎么找这个树状数组中这些元素呢？

```c++
void update(int x, int v) {
  for(int i=x;i<=N;i+=lowbit(i)) {
    c[i]+=v;
  }
}
```

**给定一个有N个正整数的序列A，对序列中的每个数，求出序列中它左边比它小的数的个数**

例如2,5,1,3,4，A[1]=2，在A[1]左边比它小的数的个数为0；A[2]=5，在它左边比它小的整数的个数为1

- 使用数组的解法

```c++
int calc(vector<int>& nums, int x) {//nums为序列，x为第几个元素
  int memo[N] = {0}//memo[i]表示i出现的次数
  int target = nums[x];//第x个元素
  for(int i=0;i<x;i++) {//前x-1个元素中，各个整数出现的次数
    target[nums[i]] += 1;
  }
  int ans = 0;
  //累加小于targe的整数出现的次数
  for(int i=0;i<target;i++) {
    ans += memo[i];
  }
  return ans;
}
```

- 使用树状数组的解法

```c++
inline int lowbit(int x) {
  return x & (-x);
}
int C[MAXN];//树状数组
void update(int x, int v) {
  for(int i=x;i<MAXN;i += lowbit(i)) {
    C[i] += v;
  }
}
void getSum(int x) {
  int sum = 0;
  for(int i=x;i>0;i -= lowbit(i)) {
    sum += c[i];
  }
  return sum;
}

int main() {
  int n, x;//n为元素个数
  C = {0};
  for(int i=0;i<n;i++) {
    scanf("%d", &x);//获取档次输入的元素
    update(x, 1);//x出现的次数+1
  }
  int target;
  scanf("%d", &target);
  printf("%d", getSum(target-1));
}
```

