### 一、可见性

#### 1. 失效数据

> 最低安全性
>
> 在线程没有同步的情况下读取变量时，可能会得到一个失效值。但至少这个值是由之前的某个线程设置的值，而不是一个随机值。

#### 2. 非原子的64位操作

> JVM允许将64位数值变量(long 和 double)的读和写操作分解成两个32位的操作。当读取一个非volatile的long变量时，如果对该变量的读写分别在不同的线程执行，那么可能会读取到不同数据的高32位和低32位。
>
> 在多线程中，必须将64位的数据用volatile保护起来。

#### 3. 加锁与可见性

> 加锁的含义不仅仅是局限于互斥行为，挨包括内存可见性。为了确保所有线程都能得到共享变量的最新值，所有执行读操作或者写操作的线程都必须在同一个锁上同步。

#### 4. volatile变量

> 当把变量声明位volatile时，编译器和运行时都会注意到这个变量是共享的。因此不会将该变量上的操作与其他内存操作一起重排。volatile变量不会在寄存器或其他处理器不可见的地方进行缓存。因此在读取volatile变量时总会返回最新写入的值。
>
> 访问volatile变量时不会执行加锁操作，因此不会使执行线程堵塞。volatile变量是比synchronized关键字更轻量的同步机制。
>
> volatile变量通常用作某个操作完成、发生终端或者状态的标记。
>
> 加锁机制既可以确保可见性，也可以确保原子性；volatile变量只能确保可见性。

### 二、 发布与溢出

> 对象能在当前作用域之外的代码中使用，称为**发布**（例如public static 变量）。
>
> 某个不该发布的对象被发布时，叫做**溢出**。

### 三、线程封闭

> 仅在各自线程中内访问数据，就不需要同步。

#### 1. Ad-hoc 线程封闭

> 维护线程封闭性的职责完全由程序实现来承担。

#### 2 . 栈封闭

> 方法内使用局部变量，局部变量位于线程的栈当中。

#### 3. ThreadLocal

> 规范的方式是使用ThreadLocal。当某个频繁执行的操作需要一个临时对象，而同时又希望能避免在每次执行中重新分配临时对象，就可以使用ThreadLocal。

### 四、不变性

> 如果某个对象在被创建后其状态就无法修改，那么就称为不可变对象。
>
> 不可变对象一定是线程安全的。
>
> 满足下列条件时，对象才是不可变的：
>
> - 对象创建以后的状态不能改变。
> - 对象的所有field都是final。
> - 对象是正确创建的（创建期间，this对象没有溢出）。

#### 1. final 域

> final域能确保初始化过程的安全性，从而可以不受限制的访问不可变对象。

#### 2. 安全发布的常用模式

> - 在静态初始化函数中初始化一个对象的引用。
> - 将对象的引用保存到volatile类型的域或者AtomicReference对象中。
> - 将对象的引用保存到某个正确构造对象的final域中。
> - 将对象的引用保存到一个由锁保护的域中。



