# 对象已死吗

## 引用计数算法
给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；引用失效时，计数器值就减一；任何时刻计数器为0的对象就是不可能再被使用的。**但是对象之间相互引用，在设置为null后却无法解决**。

## 可达性分析算法(Reachability Analysis)
基本思路是通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始往下搜索，走过的路径称为引用链(Reference Chain)，当一个对象到GC Roots没有任何引用链时，证明此对象可以被回收。
![image](https://raw.githubusercontent.com/weikano/NoteResources/master/18.png)
在Java语言中，可作为GC Roots对象的包括下面几种：
- VM栈(栈帧中的本地变量表)中引用的对象。
- 方法去中类静态属性应用的对象。
- 方法区中常量引用的对象。
- 本地方法栈中JNI应用的对象。

## 再谈引用
- 强引用
> 类似Object obj = new Object()这类，只要强引用还存在，垃圾回收器永远不会回收掉被引用的对象。
- 软引用(SoftReference)
> 对于软引用关联着的对象，在系统将要发生OOM之前，将会把这些对象列入回收范围中进行第二次回收。如果回收后还没有足够的内存，那么会OOM。
- 弱引用(WeakReference)
> 被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存是否走过，都会回收掉被弱引用关联的对象。
- 虚引用(PhantomReference)
> 一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用获取一个对象的实例。为一个对象设置虚引用关联的唯一目的是在这个对象被回收时能收到一个通知。

## 生存还是死亡
要宣告一个对象死亡，至少要经历两次标记过程：
1. 如果对象在进行可到达性分析后发现没有与GC Roots关联的引用链，那么会被第一次标记并且进行一次筛选，筛选的条件是此对象是否必要执行finalize方法。当对象没有覆盖finalize方法或者finalize方法已经被VM调用过，VM将这两种情况都是为"没有必要执行"。
2. 如果被判定为有必要执行finalize方法，那么对象会被放置在一个叫做F-Queue的队列中，并在稍后由一个由VM自动建立低优先级的Finalizer线程去执行它。这里的"执行"是指VM会触发这个方法，但并不承诺会等待它运行结束，这样做是因为finalize方法可能执行缓慢或者发生了是循环，将很可能导致F-Queue队列中其他对象处于永久等待，甚至导致整个内存回收系统崩溃。finalize方法是对象逃脱死亡命运的最后一次机会，稍后GC将堆F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize中拯救自己-只要重新与引用链上的任何一个对象建立关联即可，比如把自己赋值给某个类的变量或者对象的成员变量，那么在第二次标记时它将被移除出"即将回收"的集合；如果对象没有逃脱，那么基本上它就真的被回收了。

## 回收方法区
永久代(HotSpotVM中的方法区)主要回收两部分内容：废弃常量和无用的类。
- 废弃常量
> 计入一个字符串"abc"已经进入常量池中，但是当前系统没有任何一个String对象是叫做"abc"的，如果这时发生了GC，而且必要的话，这个"abc"常量会被系统清理出常量池。常量池中的其他类，接口，方法，字段的符号引用也类似。
- 无用的类
> **VM可以堆满足下述3个条件的无用类进行回收，并不是必然回收**。
> 1. 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。
> 2. 加载该类的ClassLoader已经被回收。
> 3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。  

# 垃圾收集算法

## 标记清除算法
> 首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象。

**主要不足有两个**：
1. 效率问题。标记和清除两个过程的效率都不高。
2. 空间问题。标记清除后会产生大量不连续的内存碎片。空间碎片太多可能会导致以后在程序进行过程中要分配大对象时，无法找到足够的连续内存而不得不触发一次GC。

## 复制算法
> 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块内存用完，就将还存活着的对象复制到另外一块上，然后再把已使用过的内存空间一次清理掉。

**不足**：
1. 将内存缩小为原来的一半。  
2. 对象存活率较高时复制频繁。
3. 需要有额外的空间进行分配担保。
  
  
现在商业VM都采用复制算法，只是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。回收时将Eden和Survivor中存活着的对象复制到另外一块Survivor上。HotSpot默认Eden和Survivor的大小比例是8:1。  
  
  
我们没法保证每次回收都只有不足10%的对象存活，当Survivor空间不够用时，需要依赖其它内存(老年代)进行担保分配(Handle Promotion)

## 标记-整理算法
> 标记过程跟标记清除算法一样，后续步骤则是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

## 分代收集算法
> 根据对象存活周期的不同将内存划分为几块。一般把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。新生代采用复制算法，老年代这使用标记清除或者标记整理。

# HotSpot的算法实现
## 枚举根节点
目前主流JVM使用的都是准确式GC，在hotspot中使用了OopMap的数据结构来记录哪些地方存放着对象引用。
## 安全点
在OopMap的协助下，hotspot可以快速准确的完成GC Roots枚举，但是如果为每一条指令都生成对应的OopMap，那么将会需要大量的额外空间。  
  
    
安全点(Safepoint)，即程序执行时并非在所有地方都能停顿下来执行GC，只有在到达安全点时才能暂停。**安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选点的，比如方法调用，循环跳转，异常跳转等**。  
  
    
对于Safepoint，另一个需要考虑的问题是如果在GC时让所有GC都跑到最近的safepoint再停顿下来。这里有两种方案供选择：抢先式中断(Preemptive Suspension)和主动式中断(Voluntary suspension)。  
  
    
抢先式中断
> 不需要线程的执行代码主动配合，在GC时，首先把所有线程全部中断，如果发现有线程中断的地方不在safepoint，就恢复线程，让它跑到safepoint。几乎没有VM采用这个模式。

主动式中断
> 当GC需要中断线程时，不直接对线程进行操作，仅仅简单的设置一个标记，各个线程执行时主动去轮询这个标记，发现中断为true时就自己中断挂起。轮询标记的地方和safepoint是重合的，另外再加上创建对象需要分配内存的地方。

## 安全区域
safepoint只处理了程序执行时，如果程序不执行就是没有分配CPU时间，典型的例子是出于sleep状态或者blocked状态，这时候线程无法响应JVM的中断请求走到safepoint，JVM也显然不太可能等待线程重新被分配CPU时间。这时候就需要安全区域(Safe Region)来解决。  
  
    
**安全区域是指在一段代码片段中，引用关系不会发生变化。在这个区域的任意地方开始GC都是安全的。可以把safe region看成safe point的扩展。**  
  
    
在线程执行到safe region时，首先标识自己进入safe region，这样当JVM发起GC时，就会忽略该线程。当线程要离开safe region时，他要检查系统是否已经完成根节点枚举(或者整个GC过程)，如果完成就继续执行，否则就必须等待直到收到可以安全离开safe region的信号为止。

# 垃圾收集器
![image](https://raw.githubusercontent.com/weikano/NoteResources/master/19.png)
## Serial收集器
> **单线程收集器，工作时必须暂停其他所有的工作线程，直到它收集结束**。优点是简单高效，对于限定CPU的环境来说，Serial收集器由于没有线程交互的开销自然可以获得最高的单线程收集效率。

![image](https://raw.githubusercontent.com/weikano/NoteResources/master/20.png)

## ParNew收集器
> Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为一致，除开Serail收集器之外，只有它能跟CMS收集器协同工作。
![image](https://raw.githubusercontent.com/weikano/NoteResources/master/21.png)
- 并行(parallel)
> 指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。
- 并发(Concurrent)
> 指用户线程与垃圾收集线程同时执行(但不一定会是并行的，可能会交替执行)，用户程序仍在继续执行，而垃圾收集程序处于另一个CPU上。

## Parallel Scavenge收集器
> 新生代收集器，使用复制算法，并行的多线程收集器。它的目标是达到一个可控制的吞吐量(Throughput)。所谓吞吐量就是CPU用于运行用户代码的时间与CPU中消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+GC时间)。

## Serial Old收集器
> Serial收集器的老年代版本，单线程，使用标记整理算法。
![image](https://raw.githubusercontent.com/weikano/NoteResources/master/20.png)

## Parallel Old收集器
> Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。
![image](https://raw.githubusercontent.com/weikano/NoteResources/master/22.png)

## CMS收集器
> CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。基于标记-清除算法，运作过程分为4个步骤：
> 1. 初始标记(CMS initial mark)
> 2. 并发标记(CMS concurrent mark)
> 3. 重新标记(CMS remark)
> 4. 并发清除(CMS concurrent sweep)

其中初始标记和重新标记仍然需要stop the world。初始标记仅仅只是
标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing
的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变
动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远
比并发标记的时间短。
![image](https://raw.githubusercontent.com/weikano/NoteResources/master/23.png)
CMS的主要优点: 并发收集，低停顿。
CMS的明显缺点：
1. CMS收集器对CPU资源非常敏感。会因为占用了一部分线程而导致应用程序变慢，总吞吐量降低。
2. CMS收集器无法处理浮动垃圾(Floating Garbage)，可能出现"Concurrent Mode Failure"失败而导致另一次Full GC的产生。用于CMS并发清理阶段用户线程还在运行着，伴随着程序运行自然就会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在单次收集中处理掉，称为“浮动垃圾”。也是用于在垃圾收集阶段用户线程还在运行，那也就还需要预留足够的内存空间给用户线程使用，因此CMS不能像其他收集器那样等到老年代几乎完全被填满再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。要是CMS运行期间预留的内存空间不够，就会出现"Concurrent Mode Failure"，临时启用SerialOld来GC。
3. 基于标记-清理算法，会导致大量的内存碎片，往往会出现老年代还有足够的空间剩余，但无法找到足够大的连续空间而提前出发一次FullGC。

## G1(Garbage First)收集器
G1具备以下特点:
1. 并行和并发
> G1能充分利用多CPU，多核环境的硬件优势来缩短stop-the-world时间。
2. 分代收集
> G1可以不需要其他收集器配合就能独立管理整个heap，并且能够采用不同的方式去处理新创建的对象和已经存活一段时间熬过多次GC的就对象。
3. 空间整合
> G1整体使用了标记-整理算法，从局部(Region)来看使用了复制算法。这两种算法都以为着G1运行期间不会产生内存碎片，有利于长时间运行，分配大对象时不会提前触发下一次GC。
4. 可预测的停顿
> 能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在GC上的时间不超过N毫秒。
  
  
使用G1时，Java heap的内存布局与其他收集器有很大差别，它将整个Java heap划分成多个大小相等的区域(Region)，虽然还保留着新生代和老年代的概念，但新生代和老年代不再是物理隔离的，他们都是一部分Region(不需要连续)的集合。
  
  
G1之所以能够建立可预测的停顿时间模型，是因为他可以有计划地避免在整个Java heap中进行全区域的GC。G1跟踪各个Region里面的垃圾堆积的价值大小(回收所获得的空间大小以及回收所需时间的经验值)，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的region。这种使用region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在短时间内可以获取尽可能高的收集效率。
  
  
Region不可能是完全孤立的。一个对象分配在某个region当中，它并非只能被本region中的其它对象引用，而是可以与整个Java heap的对象发生应用关系。这样就必须扫描整个Java heap来确保准确性。
  
  
G1收集器中，region之间的对象引用以及其他收集器中的新生代和老年代之间的对象引用，VM都是使用RememberedSet来避免全堆扫描。G1中的每个region都有一个与之对应的RememberedSet，VM发现程序在对reference类型的数据进行写操作时，会产生一个WriteBarrier暂时中断写操作，检查reference引用的对象是否处于不同的region当中，如果是，便通过CardTable把相关引用信息记录到被应用对象所属的region的RememberedSet之中。当GC时，在GC根节点枚举范围中加入RememberedSet即可避免全堆扫描和遗漏。
  
  
G1收集器的运作大致可划分一下几个步骤:
1. 初识标记(initial marking)
2. 并发标记(concurrent marking)
3. 最终标记(final marking)
4. 筛选回收(Live Data Couting and Evacuation)
![image](https://raw.githubusercontent.com/weikano/NoteResources/master/24.png)

## 理解GC日志

# 内存分配与回收策略

## 对象优先在Eden分配
大多数情况下，对象在新生代的Eden区中分配。如果Eden区中没有足够的空间，会发起一次minor GC。
- 新生代GC(Minor GC)
> 发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以minor GC非常频繁，一般回收速度也比较快。
- 老年代GC(Major/Full GC)
> 发生在老年代的GC，出现了major gc，经常会伴随至少一次的minor gc(非绝对，在parallel scavenge收集器的收集策略中既有直接进行major gc的策略)。major gc一般比minor gc慢10倍以上。

## 大对象直接进入老年代
直接在老年代分配大对象，可以避免新生代gc。**对JVM来说，比遇到一个大对象更坏的消息就是遇到一群朝生夕灭的短命大对象，容易触发minor gc，更可能导致major/full gc产生**。

## 长期存活的对象进入老年代
VM给每个对象定义了一个对象年龄(Age)计数器。**如果对象在Eden出生并经过第一次minor gc后仍然存活，并且能被survivor容纳的话，会被移动到survivor区域，并且见对象年龄设置为1。对象在survivor区域中每熬过一次minor gc，年龄都会增加一岁，当它的年龄到一定程度(默认15岁)，就会晋升到老年代中**。

## 动态对象年龄判定
如果在survivor区域中相同年龄所有对象的大小综合大于survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到一定程度的年龄。

## 空间担保分配
在发生minor gc之前，虚拟机会检查老年代最大可用的连续空间是否大于新生代所有对象中空间。如果成立，那么minor gc可以确保是安全的。如果不成立，这虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次minor gc，尽管有风险；如果小于，或者HandlePromotionFailure设置不允许冒险，那么执行full gc。

