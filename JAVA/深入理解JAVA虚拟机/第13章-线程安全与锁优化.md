## 线程安全

**当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的**。

### Java语言中的线程安全

1. 不可变

   > Java语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。 如果共享数据是一个对象，那就需要保证对象的行为不会对其状态产生任何影响。比如对象中所有的属性都用final修饰，这样在构造函数结束之后，它就是不可变的。

2. 绝对线程安全

   > 在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。比如java.util.Vector是一个线程安全的容器。但是如果在线程中循环添加数据，另一个线程中fori遍历循环删除数据，会出现异常。要解决这个问题，必须手动加锁。

3. 相对线程安全

   > 如果要使用线程安全的集合，考虑java.util.concurrent中的集合或者Collections.synchronized方法返回的集合。

4. 线程兼容

   > 线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。

5. 线程对立

   > 线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。



### 线程安全的实现方法

1. 互斥同步

   > Mutual Exclusion & Synchronization 是常见的一种并发正确性保障手段，也称为阻塞同步。同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个(或者是一些，使用信号量的时候)线程使用。而互斥是实现同步的一种手段，临界区(Critial Section)、互斥量(Mutex)和信号量(Semaphore)都是主要的互斥实现方式。互斥是因、方法，同步是果、目的。
   >
   > Java中最基本的互斥同步手段是synchronized关键字，编译后会生成monitorenter和monitorexit两个字节码指令，两个指令都需要一个reference类型的参数来指明要锁定和解锁的对象。**如果Java程序中没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，取对应的对象实例或class对象来作为锁对象**。
   >
   > 在执行monitorenter指令时，首先要尝试获取对象的锁。 如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。 如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止 
   >
   > **首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死的问题。 其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入**。  
   >
   > 除了synchronized之外，我们还可以使用java.util.concurrent（下文称J.U.C）包中的重入锁(ReentrantLock）来实现同步。相比synchronized,ReentrantLock增加了一些高级功能，主要有以下3项：**等待可中断、 可实现公平锁，以及锁可以绑定多个条件**。
   >
   > - 等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。
   > - 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。而非公平锁在释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的。
   > - 锁绑定多个条件是值一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait和notify或notifyAll方法可以实现一个隐含的条件，要实现多个条件关联，必须额外添加锁，而ReentrantLock则无须如此，只需要多次调用newCondition()方法即可。

2. 非阻塞同步

   > 通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。
   >
   > 在JDK 1.5之后，Java程序中才可以使用CAS(Compare And Switch)操作，该操作由sun.misc.Unsafe类里面的compareAndSwapInt（）和compareAndSwapLong（）等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程，或者可以认为是无条件内联进去了。
   >
   > CAS存在这样一个逻辑漏洞 : 如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。 这个漏洞称为CAS操作的“ABA”问题。 J.U.C包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。 不过目前来说这个类比较“鸡肋”，大部分情况下ABA问题不会影响程
   > 序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。 

3. 无同步方案

   > - 可重入代码(Reentrant Code) : 可以在代码执行阶段任何时刻中断，转而去执行另外一段代码，而在控制权返回后，原来的程序不会出现任何错误，也叫做纯代码(Pure Code)。可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、 用到的状态量都由参数中传入、 不调用非可重入的方法等。
   > - 线程本地存储(Thread Local Storage) : Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它为“易变的”；如果一个变量要被某个线程独享，Java中就没有类似C++中__declspec（thread）这样的关键字，不过还是可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。 每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以
   >   ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。



## 锁优化

### 自旋锁与自适应自锁

共享数据的锁定状态只会持续很短
的一段时间，为了这段时间去挂起和恢复线程并不值得。 如果物理机器有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的那个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。 为了让线程等待，我们只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，因此，如果锁被占用的时间很短，自旋等待的效果就会非常好，反之，如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费。

### 锁消除

锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。

### 锁粗化

如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。**如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部**。

### 轻量级锁

轻量级锁是JDK 1.6之中加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为“重量级”锁。 首先需要强调一点的是，轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 

### 偏向锁

消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。