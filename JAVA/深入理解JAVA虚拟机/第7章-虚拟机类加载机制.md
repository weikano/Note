## 概述

> VM把描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是VM的类加载机制。

## 类加载的时机

![image](https://raw.githubusercontent.com/weikano/NoteResources/master/45.png)

**记载，验证，准备，初始化和卸载这5个阶段的顺序是确定的**，类的加载过程必须按照这种顺序开始，而解析可以在初始化阶段之后再看时，这是为了支持Java的运行期绑定。

什么情况下需要开始类加载没有强制约束，交由VM的具体实现来把握。初始化阶段，VM严格规定了有且只有5种情况必须立即对类进行"初始化"(而加载，验证和准备自然需要在之前开始):

1. 遇到new, getstatic, putstatic或invokestatic这4条字节码指令时，如果没有进行过类初始化，这需要先初始化。
2. 使用reflect包的方法对类进行反射调用时，如果类没有初始化，需要先触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，这需要先出发其父类的初始化。
4. VM启动时，用户需要执行一个要执行的主类(包含main方法的那个类)，VM会先初始化这个主类。
5. 使用JDK1.7的动态语言支持时, 如果一个MethodHandle实例最后的解析结构REF_getStatic, REF_putStatic, REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有进行过初始化，这需要先触发其初始化。

以上5种成为对一个类进行主动应用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。

对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来应用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

**常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化**。

**接口的加载过程与类稍有不同。接口的初始化过程不能用static代码块来输出初始化信息，但编译期仍然会为借口生成<clinit>类构造器，用于初始化接口中定义的成员变量。真正有所区别在于第3点：当一个类在初始化时，要求其父类全部都已经初始化过，当接口并不要求其父接口全部都完成了初始化，只有真正使用到父接口的时候(如引用父接口中定义的常量)才会初始化**。

## 类加载过程

## 加载

> 在加载阶段，VM需要完成以下3件事情：
>
> 1. 通过一个类的全限定名来获取定义此类的二进制字节流。
> 2. 将字节流所代表的静态存储结构转化为方法区的运行时数据结构。
> 3. 在内存中生成一个代表这个类的class对象，作为方法区这个类的各种数据的访问入口。

对于数组类来说，数组类本身不通过类加载器创建，它是由JVM直接创建的。但是数组类的元素类型最终要靠类加载器来创建。一个数组类创建过程遵循一下规则：

- 如果数组的组建类型(Component Type)是引用类型，那就递归采用本节中定义的加载过程去加载这个组建类型，数组将在加载该组建类型的类加载器的类名称空间上被标识。
- 如果数组的组件类型不是引用类型(如int[])，JVM将会把数组标记为与引导类加载器关联。

## 验证

> 连接阶段的目的是为了确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

验证阶段大致上会完成下面4个阶段的校验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

1. 文件格式验证。可能包括下面这些验证点：是否一魔术oxCAFEBABE开头。主次版本号是否在当前VM处理范围之类。常量池的常量中是否有不被支持的常量类型(检查tag标志)。指向常量的各种索引值是否有指向不存在的常量或不符合类型的常量。CONSTANT_Utf8_info型常量是否有不符合UTF-8编码的数据。class文件中各个部分以及文件本身是否有被删除或附加的其他信息。
2. 元数据验证。这个类是否有父类(除了object之外，所有类都应当有父类)。这个类的父类是否继承了不允许被继承的类(被final修饰的类)。如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法。类中的字段、方法是否与父类产生矛盾(例如覆盖了父类的final字段，或者出现不符合规则的方法重载，例如方法参数一致，但返回值类型却不同等)。**主要目的是对类的元数据信息进行语义校验，保证不存在符合Java语言规范的元数据信息**。
3. 字节码验证。通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对方法提进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。
4. 符号引用验证。符号引用中通过字符串描述的全限定名是否能找到对应的类。在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段。符号引用中的类、字段、方法的访问型是否可被当前类访问。**目的是确保解析动作能够正常执行**。

## 准备

> 准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，将在方法区中进行分配。两个容易长生混淆的概念：**首先这个时候进行内存分配的仅包括类变量(被static修饰)，而不包括实例变量。实例变量在对象实例化时随着对象一起分配的Javaheap中；其次，这里所说的初始值通常情况下是数据类型的零值。比如public static int value = 123。那么value在准备阶段过后的初始值为0而不是123，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>方法中，所以把value赋值为123的动作在初始化阶段才会执行**。

如果类字段为常量，比如public static final int value = 123，那么在准备阶段变量value就会被初始化为ConstantValue的设置将value赋值为123。

## 解析

> 解析阶段是VM将常量池内的符号引用替换为直接引用的过程。

符号引用(Symbolic Reference)

> 用一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能无歧义地定位到目标即可。

直接引用(Direct Reference)

> 直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那么引用的目标一定已经在内存中存在。

- 类或接口的解析。假设当前代码所在的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那么需要以下3个步骤
  1. 如果C不是一个数组类型，那么VM会把代表N的全限定名传递给D的类加载器去加载这个类C。
  2. 如果C是数组类型，并且数组元素类型为对象，也就是N的描述符会是类似"[Ljava/lang/Integer"的形式，那么会按照第1点的规则加载数组元素类型。如果N的描述如前面所假设的形式，需要加载的元素类型为"java.lang.Integer"，接着VM生成一个代表此数组维度和元素的数组对象。
  3. 如果上面步骤没出现异常，那么C在VM中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。如果不具备，抛出java.lang.IllegalAccessError。

- 字段解析

  > 要解析一个未被解析过的字段符号引用，首先会对字段表内class_index项中索引的Constant_Class_info符号引用进行解析，也就是字段所属的类或接口的符号引号引用。计息成功后，将这个字段所属的类或接口用C表示。

  1. 如果C本身包含了简单名称和字段描述符都与目标相匹配的字段，返回这个字段的直接引用，查找结束。
  2. 否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标匹配的字段，则返回这个字段的直接引用，查找结束。
  3. 否则，如果C不是java.lang.Object的话，将会安装继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标匹配的字段，则返回这个字段的直接引用，查找结束。
  4. 否则，超找失败，抛出java.lang.NoSuchFieldError。

- 类方法解析

  > 类方法解析的第一个步骤与字段解析一样，也需要解析出类方发表的class_index项中索引的方法所属的类或接口的符号引用，如果成功，用C表示。

  1. 类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是接口，那就直接抛出java.lang.IncompatibleClassChangeError。
  2. 如果通过第1步，在C中查找是否具有简单名称和描述符都与目标匹配的方法，如果有则返回这个方法的直接引用，查找结束。
  3. 否则，在类C的父类中递归查找是否有简单名称和描述符都与目标匹配的方法，如果有则返回这个方法的直接引用，查找结束。
  4. 否则，在类C实现的接口列表及它们的父接口之中递归查找是否具有简单名称和描述符都与目标匹配的方法。如果存在匹配的方法，说明C是一个抽象类，这时查找结束，抛出java.lang.AbstractMethodError异常。
  5. 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError。

- 接口方法解析

  > 用C标识接口方法表class_index项中索引的方法所属的类或接口的符号引用

  1. 与类方法解析不同，如果在接口方发表中发现class_index中的索引C是个类而不是接口，直接抛出java.lang.IncompatibleClassChangeError。
  2. 否则，在接口C中查找是否有简单名称和描述符与目标匹配的方法，如果有则返回方法的直接引用，查找结束。
  3. 否则，在接口C的父接口中递归查找，知道java.lang.Object类为止，看是否有简单名称和描述符与目标匹配的方法，有则返回方法的直接引用，查找结束。
  4. 否则，查找失败，抛出java.lang.NoSuchMethodError。

## 初始化

> 到了初始化阶段，才真正开始执行类中定义的Java程序代码(或者说字节码)。

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序制定的主观计划去初始化变量和其它资源，**初始化阶段是执行类构造器clinit方法的过程**。 

clinit方法是由编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态代码块中只能访问到定义在静态代码块之前的变量，之后的变量，在前面的静态代码块可以赋值，但不能访问。

clinit与类的构造函数(init)方法不同，它不需要显示调用父类构造器，VM会保证在子类的clinit方法执行之前，父类的clinit方法已经执行完毕。因此，在VM中第一个被执行的clinit的类一定是java.lang.Object。



## 类加载器

### 类与类加载器

> 比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意
> 义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类
> 加载器不同，那这两个类就必定不相等 

### 双亲委派模型

- 启动类加载器(Bootstrap ClassLoader)：负责将存放在java_home/lib目录中的，或者被-Xbootclasspath参数指定的路径中的，并且是VM识别的类库加载到VM内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果要把加载请求委派给引导类加载器，那直接用null代替即可。
- 扩展类加载器(Extension ClassLoader)：有sun.misc.Launcher$ExtClassLoader实现，负责加载java_home/lib/ext目中的，或者被java.ext.dirs系统变量指定路径中的所有类库，开发者可以直接使用。
- 应用程序类加载器(Application ClassLoader)：由sun.misc.Launcher$AppClassLoader实现，一般也被称为系统类加载器，负责加载用户类路径(classpath)上指定的类库。如果没有自定义过自己的类加载器，一般情况下就是程序默认的类加载器。

![image](https://raw.githubusercontent.com/weikano/NoteResources/master/46.png)

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己
去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是
如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈
自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自
己去加载。 

### 破坏双亲委派模型

略。

