# 运行时数据区域
![image](https://raw.githubusercontent.com/weikano/NoteResources/master/16.png)

## 程序计数器
程序计数器(Program Counter Register)是一块较小的内存空间, 可以看作当前线程所执行的字节码的行号指示器. 字节码解释器工作时就是通过该表这个计数器的值来获取下一条需要执行的字节码指令, 分子循环跳转异常处理线程恢复等基础功能都依赖它。  
  
    
由于JVM的多线程是通过时间片的方式来实现的，在任何一个确定的时刻，一个处理器(多核CPU来说是一个内核)都只执行一条线程中的指令。因此为了切换线程后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器来确保互不影响。  
  
    
如果线程执行的是JAVA方法， 那么计数器记录的是正在执行的JVM字节码指令的地址；如果是NATIVE方法，那么这个计数器值为空（Undefined）。**此内存区域是唯一一个在JVM规范中没有规定任何OOM情况的区域。**

## JVM栈
**JVM栈(Java Virtula Matchine Stacks)也是线程私有的，它的生命周期与线程相同**。JVM栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至完成的过程，对应着一个栈帧在JVM栈中入栈到出栈的过程。  
  
  
局部变量表存放了编译期可知的各种基本类型，对象应用（reference类型，不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是一个代表对象的句柄或其他与此对象相关的位置）和returnAddress（指向了上一条字节码指令的地址）。  
  
  
其中64位长度的long和double类型的数据会占用两个局部变量空间(Slot)。**局部变量表所需的内存空间在编译期间完成分配，在方法运行期间不会改变局部变量表的大小。**  
  
  
在JVM规范中，这个区域有两种异常：如果线程请求的深度大于虚拟机所允许的深度，抛出StackOverflowError；如果虚拟机栈可以动态扩展且扩展时无法申请到足够的内存，抛出OOM。

## 本地方法栈
与JVM栈类似，为JVM使用的Native方法服务。也会抛出StackOverflowError和OOM。

## Java堆
Java堆（Java Heap）是JVM说管理的内存中的最大的一块。Java堆是被所有线程共享的一块内存区域，在JVM启动时创建。此区域的唯一母的是存放对象实例，几乎所有的对象实例都在这里分配内存。**JVM规范中描述到：所有的对象实例以及数组都要在堆上分配，但是随之JIT编译期的发展和逃逸分析技术的逐渐成熟，栈上分配标量替换优化技术将会导致一些微妙的变化产生，所有的对象在堆上进行渐渐不是那么“绝对”了。**  
  
  
Java堆是垃圾收集器管理的主要区域，因此也被称作"GC"堆（Garbage Collected Heap）。从内存回收的角度来看，由于收集器基本都采用分代手机算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点有Eden空间，From Survivor空间，To Survivor空间等。从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。  
  
  
根据JVM规范，Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续。如果没有足够的内存完成实例分配，会抛出OOM。

## 方法区
**方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，用于存储已被JVM加载的类信息，常量，静态变量，即时编译期编译后的代码等。**虽然JVM规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作Non-Heap。  
  
  
方法去的内存回收目标主要是针对常量池的回收和堆类型的卸载。根据JVM规范，当方法区无法满足内存分配需求时，都会抛出OOM。

## 运行时常量池
运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号医用，这部分内容将在类加载后进入方法区的运行时常量池中存放。符号引用和直接引用的概念参照第6章。  
  
  
**运行时常量池相对于class文件常量池的另外一个重要特性是具备动态性，运行期间也可能将新的常量放入此种，比如String.intern();**  
  
  
**运行时常量池是方法区的一部分，所以当常量池无法再申请到内存时会OOM。**

## 直接内存
直接内存（Direct Memory）并不是JVM运行时数据区的一部分，也不是JVM规范中定义的内存区域。但是这部分内存也被频繁使用，也可能导致OOM。

# HotSpot 虚拟机对象揭秘

## 对象的创建
**文中讨论的对象限于普通的Java对象，不包括数组和class对象等。**  
  
  
JVM遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载，解析和初始化过。如果没有，那必须先执行相应的类加载过程，第7章。  
  
  
类加载检查通过后，JVM会为新生对象分配内存。假设Java堆中的内存是绝对规整的，所有用过的内存都放在一边，空闲的在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把指针向空闲内存空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”(Bump the Pointer)。如果Java堆中的内存并不是规整的，已使用内存和未使用内存交错，JVM就必须维护一个列表，记录哪些内存块可用，在分配的时候从列表中找到一块足够大的空间划分给对象实例并更新内存列表中的记录，这种分配方式成为“空闲列表”(Free List)。  
  
  
对象创建是JVM中非常频繁的行为，所以要考虑并发情况下的线程安全。解决这个问题有两种方法，一种是堆分配内存空间的动作进行同步处理-JVM采用CAS配上失败重试的方式保证更新操作的原子性；另一种是把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程缓冲（Thread Local Allocation Buffer），只有TLAB用完并分配新的TLAB时，才需要同步锁定。  
  
  
内存分配完成后，JVM需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初值就可以直接使用。  
  
  
接下来，JVM要对对象进行必要的设置，比如这个对象是哪个类的实例，任何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息，存放在对象头(Object Header)中。  
  
  
上面工作完成后，从JVM角度看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始--<init>方法还没有执行，所有的字段都还为零值。一般来说(由字节码中是否跟随invokespecial指令决定)，执行new指令后会接着执行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

## 对象的内存布局
在hotspot VM中，对象在内存中的存储布局可以分为3块：对象头(Header)，实例数据(Instance Data)和对齐填充(Padding)。  
  
- 对象头  
hotspot VM的对象头包括两部分信息：第一部分用于存储对象本身的运行时数据，比如hashcode，GC分代年龄，锁状态标志，线程持有的锁，偏向线程ID，偏向时间戳等，这部分数据的长度在32bit和64bit的VM中分别为32bit和64bit，官方称为“Mark Word”；另一部分是类型指针，即对象指向它的类元数据的指针，VM通过这个指针来确定对象是哪个类的实例。另外，如果对象为数组，那么在对象头还必须有一块用于记录数组长度的数据，因为VM可以通过普通的Java对象的元数据确定对象的大小，却无法确定数组的大小。


- 实例数据  
实例数据部分是对象真正存储的有效信息，也是在代码中定义的各种类型的字段内容。存储顺序会受到VM分配策略参数(FieldsAllocationStyle)和字段在Java源码中定义顺序的影响。从分配策略中可以看出，相同宽度的字段总是被分配到一起，父类中定义的变量会出现在子类之前。如果CompactFields参数值为true，那么子类中较窄的变量也可能会插入到父类变量的空隙之中。


- 对齐填充  
对齐填充并不是必然存在，也没有特别的含义，仅仅起着占位符的作用。

## 对象的访问定位
目前主流的访问方式有使用句柄和直接指针两种。  
  
  
- 使用句柄访问  
那么Java堆中会划分出一块内存来作为句柄池， reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。
![image](https://raw.githubusercontent.com/weikano/NoteResources/master/15.png)
- 使用直接指针访问  
Java堆中对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。
![image](https://raw.githubusercontent.com/weikano/NoteResources/master/17.png)

使用句柄访问的最大好处是reference中存储的是稳定的句柄地址，在对象被移动时只会改变对应的实例数据指针，而reference本身不需要修改。  
  
  
使用直接指针访问的最大好处是速度快，它节省了一次指针定位的时间开销。

# 实战：OOM

## Java堆溢出
具体的堆转储快照文件分析，参照第四章。

## VM栈和本地方法栈溢出

## 本机直接内存溢出

## 方法区和运行时常量池溢出