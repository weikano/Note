## Delegation

### Class Delegation

kotlin支持代理模式的方法很简单，如下所示

```kotlin
//定义接口
interface Base {
  fun print()
}
//实现类
class BaseImpl(val x : Int) : Base {
  override fun print() {
    println(x)
  }
}
//代理，by为关键字，语法:接口by参数名
class Derived(b : Base) : Base by b

fun main(args : Array<String>) {
  Derived(BaseImpl(10)).print()
}
```

kotlin会在编译时生成代理相关的代码，类似Java中的写法

### Delegated Properties

kotlin支持property 代理，代码如下

```kotlin
class Example {
  var p : String by Delegate()
}

class Delegate {
  operator fun getValue(thisRef : Any ?, property : KProperty<*>) : String {
    println("$thisRef, thanke you for delegating '${property.name}' to me")
    if(thisRef is String) {
      return thisRef
    }
    return "WTF"
  }
  
  operator fun setValue(thisRef : Any ? , property : KProperty<*>, String value) {
    println("$value has been assigned to '${property.name} in $thisRef.'")
  }
}
```

实现语法很简单

**val/var <property name> : <Type> by <expression>。by之后的expression就是代理，而代理只需要实现getValue和setValue方法即可，注意前面的operator关键字**

**编译后的class文件可知，是在Example中插入了一个Delegate对象，并在Example中p的getter和setter中使用Delegate对象的getValue和setValue方法来进行代理**

### Standard Delegates

kotlin standard library 提供一些工厂方法来实现很多有用的不同类型的代理

#### Lazy

```kotlin
val P : String by lazy {
  println("lazy initialize")
  "hello"
}

fun main(args : Array<String>) {
  println(p)
  println(p)
}
```

语法很简单：**val/var <property name> : <Type> by lazy <expression>。by之后的expression为initializer，相关kotlin代码主要为Lazy.lazy()方法。先判断property的值是否为UNINITIALIZED_VALUE，是，则调用initializer并赋值，否则直接返回property的值**。

#### Observable

```
class AdminUser {
  var name : String by Delegates.observable("initial value") {
    prop, old, new -> 
    println("$old -> $new")
  }
}

fun main(args : Array<String>) {
  val o = AdminUser()
  o.name - "hello" // initial value -> hello
  o.name = "world" // hello -> world
}
```

语法: **var/val <property name> : <Type> by Delegates.observable<initalValue : Type, onChange: (property: KProperty<*>, oldValue: T, newValue: T) -> Unit)**

**onChange可以为lambda表达式形式，prop为KProperty，old为原来的值，new为改变后的值**

**kotlin实现该功能使用的仍然是代理模式，主要类为Delegates.observable方法，通过ReadWriteProperty:ObservableProperty类来实现。编译后的class文件在AdminUser中name的setter和getter中调用ReadWriteProperty.onChange方法来通知。**

### Map

```
class AdminUser(maps : Map<String,Any?>) {
  val name : String by maps
  val age : Int by maps
}

fun main(args : Array<String>) {
  val o = AdminUser(mapOf(
  	"name" to "Me",
  	"age" to 10
  ))
  println(o.name +"," + o.age)//Me 10
}
```

**kotlin通过MapsKt中的getOrImplicitDefaultNullable来进行代理，即Maps.kt中的getOrElseNullable方法**

**注意：由于Map只实现了operator getValue()，没有实现operator setValue()方法，所以只能对val变量使用**

#### Local Delegated Properties(本地变量的delegate)

```kotlin
fun example(computeFoo : () -> Foo) {
  val memorized by lazy(computeFoo)
  if(someCondition && memorized.isValid()) {
    memorized.doSomething()
  }
}
```

### Property Delegate Requirments

对val来说，需要实现operator fun getValue(thisRef : Type ? , property : KProperty<*>)

对var来说，不仅仅要实现getValue，还需要setValue(thisRef : Type ?, property:KProperty<*>, value : ValueType)。

对每个代理的property prop来说，kotlin都会编译生成一个prop$delegate property，编译后的具体kotlin如下

```kotlin
class C {
  var prop: Type by MyDelegate()
} 
// this code is generated by the compiler instead:
class C {
  private val prop$delegate = MyDelegate()
  var prop: Type
    get() = prop$delegate.getValue(this, this::prop)
	set(value: Type) = prop$delegate.setValue(this, this::prop, value)
}
```

### ProvideDelegate

> TBD