## 结构体、位运算以及其他

### C语言结构体（struct）

```c
struct 结构体名 {
  //结构体包含的变量或数组
};//分号不能少，这是一条完整的语句
```

#### 成员的获取和赋值

获取结构体成员和赋值的一般格式是：

```c
struct student stu1;
stu1.name = "Tom";
stu1.age = 22;
//......如此这般，对成员逐一赋值
```

**整体赋值仅限于定义结构体变量的时候，使用过程中只能对成员逐个赋值**。

```c
struct student {
  char *name;
  int age;  
} stu1, stu2 = {"Tom",22};
```

**需要注意的是，结构体是一种自定义的数据类型，是创建变量的模板，不占用内存空间；结构体变量才包含了实实在在的数据，需要内存空间来存储**。

### 结构体和指针

```c
struct 结构体名 *变量名
```

通过结构体指针获取结构体成员

```c
pointer -> memberName;
```

### 共用体（Union）

```c
union 共用体名{
  成员列表
}
```

结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其他所有成员。

结构体占用的内存大于所有成员占用的内存的综合（成员之间可能有间隙），共用体占用的内存等于最长的长远占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。

### 位域

在结构体定义时，我们可以指定某个成员变量所占用的二进制位数(Bit)，这就是位域。

```c
struct bs {
  unsigned m; //没有限制,占用4个字节(byte)
  unsigned n : 4; //占用4个Bit
  unsigned char ch : 6;//占用6个bit。
}
```

:后面的数字用来限定成员变量占用的位数。

**位域的宽度不能超过它所依附的数据类型的长度。在ANSI C中，int、unsigned int和signed int可以用于位域；C99中，_Bool也被支持**。

**位域成员往往不占用完整的字节，有时候也不处于字节的开头位置，因此使用`&`获取位域成员的地址是没有意义的，C语言也禁止这样做。地址是字节（Byte）的编号，而不是位（Bit）的编号**。

### 位运算

- 按位异或运算（^）

  > 参与^运算的两个二进制位不相同时，结果为1，相同时结果为0。例如0^1=1,1^1=0,0^0=0。
  >
  > 按位异或运算可以用来将某些二进制位反转。例如要把n的高16位就行反转，可以进行n^0xFFFF0000。

- 取反运算（~）

  > 取反运算符为单目运算符，右结合性，作用是对参与运算的二进制位取反。例如~1=0，~0=1。

- 左移（<<）

  > 把操作数的各个二进制位全部左移若干位，高位丢弃，低位补0。

- 右移（>>）

  > 把操作数的各个二进制位全部右移若干位，低位丢弃，高位补0或1。如果数据的最高位是0，那么就补0，如果最高位是1，那么就补1。



### typedef 别名

```c
//typedef oldName newName;
typedef int INTEGER;//int别名
typedef char ARRAY20[20];//char[20]数组别名
typedef struct stu {//结构体stu别名
  char name[20];
  int age;
} STU;


INTEGER a, b;
a = 1;
b = 1;
ARRAY20 a1, a2, s1, s2;
STU stu1, stu2;
```

typedef和#defined的区别：

1. 可以使用其他类型说明符对宏类型名进行扩展，但对typedef所定义的类型名却不能这样做。

   > ```c
   > #define INTEGER int
   > unsigned INTEGER n;//可以
   >
   > typedef int INTEGER1;
   > unsigned INTEGER1 n;//错误，不能在INTEGER1前面添加unsigned
   > ```

2. 在连续定义几个变量的时候，typedef能够保证所定义的所有变量均为同意类型，而#defined无法保证。

   > ```c
   > #define PTR_INT int *
   > PTR_INT p1, p2;//int *p1, p2，结果p1为指向int的指针，p2为int类型
   > ```
   >
   > ```c
   > typedef int * PTR_INT;
   > PTR_INT p1, p2;//p1,p2都会指向int的指针
   > ```



### const：禁止修改变量的值

```c
const type name = value;
```

#### const和指针

```c
//p1,p2指向的数据是只读的，也就是p1，p2本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。
const int *p1;
int const *p2;
//指针是只读的，p3本身的值不能修改。
int * const p3;
```

**const离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据。如果近的远的都有，那么就同时修饰指针变量以及它指向的数据（？有疑问，根据上述代码中的p1, p2, p3，应该用\*来判断）**。

