## C语言指针

### 一分钟彻底理解C语言指针的概念

> CPU访问内存时需要的是地址，而不是变量和函数名。变量名和函数名只是地址的一种助记码，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。编译和链接的一项重要任务就是找到这些名称对应的地址。

### 大话C语言指针变量

> 数据在内存中的地址称为指针。如果一个变量存储了一份数据的指针，我们就称它为指针变量。

#### 定义指针变量

```c
datatype *name;
//或者用下面的方式
datatype *name = value;
```

*便是这是一个指针变量，datatype表示该指针变量所指向的数据的类型。

**定义指针变量时必须带*，给指针变量赋值时不能带***。

指针变量存储了数据的地址，通过指针变量能够获得该地址上的数据，格式为：

```c
*pointer;
```

CPU读写数据必须要知道数据在内存中的地址，普通变量和指针变量都是地址的助记符，虽然通过pointer和a直接获取到的数据一样，但它们的运行过程稍有不太能够：a只需要一次运算就能获取到数据，而pointer要先通过地址取得变量P本身的值，这个值是a的地址，然后再通过这个地址取得变量a的数据。

**也就是说，使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者代价要高**。

#### 关于*和&的谜题

假设有一个int类型的变量a，pa是指向它的指针，那么\*&a和&\*pa分别代表什么意思？

```
int a = 10;
int *pa = &a;
```

1. \*&a可以理解为\*(&a)，&a为变量a的地址(等价于pa)，\*(&a)表示取这个地址上的数据(等价于\*pa)，即

   ```
   *&a = *(&a) = *(pa) = a;
   ```

2. &\*pa可以理解为&(\*pa)，\*pa表示取得pa指向的数据(等价于a)，&\*pa表示数据的地址，等价于&a，所以

   ```
   &*pa = &(*pa) = &a
   ```

#### 对星号*的总结

- 表示乘法
- 表示定义一个指针变量，以和普通变量区分开。例如int a = 100; int *pa = &a;
- 表示获取指针变量指向的数据，是一种间接操作，例如int a, b, *p=&a; \*p=100;b=\*p;

### C语言数组指针（指向数组的指针）

> 我们将第0个元素的地址称为数组的首地址，数组中的元素在内存中是连续的。

假设p是指向数组arr中第n个元素的指针，那么\*p++、\*++p、(\*p)++：

- \*p++等价于\*(p++)，表示先取得第n个元素的值，再将p指向下一个元素。
- \*++p等价于*(++p)，先进行++p运算，是的p指向下一个元素，整体上相当于\*(p+1)，所以会获取第n+1个数组元素的值。
- (\*p)++，先取得第n个元素的值，然后在对该值加1。

### C语言字符串指针（指向字符串的指针）

```c
//字符数组表示字符串
char str[] = "Hello World !";
//指针指向字符串
char* pstr = "Hello World !";
```

上述两者方式的区别：

- 字符数组存储在全局数据区或栈区。
- 指针方式的字符串存储在常量区。
- 全局数据区或栈区的字符串（包括其他数据）有读取和写入的权限，而常量区的数据只有读取权限，没有写入权限。

```c
#include <stdio.h>
int main()
{
  char *str = "Hello World";
  str = "I love C";//correct
  str[3] = "P"; //error
  return 0;
}
```

**可以更改指针本身的指向，但不能更改字符串中的字符**。

**那么到底使用字符串数组还是字符串常量**？

> 如果只涉及到读取，那么都可以；如果需要写入（修改）操作，使用字符串数组。
>
> 比如获取用户输入的字符串时，必须使用字符串数组。

**当数组作为参数传递给函数时，那么数组名会立刻转换为指向该数组第一个元素的指针。C语言会自动的将作为参数的数组转换为相应的指针声明**。

### 用C语言指针作为函数返回值

```c
#include <stdio.h>
#include <string.h>

char *strlong(char *str1, char *str2)
{
  if(strlen(str1) >= strlen(str2)) {
    return str1;
  }else {
    return str2;
  }
}

int main()
{
  char str1[30], str2[30], *str;
  gets(str1);
  gets(str2);
  str = strlong(str1, str2);
  printf("longer string is %s", str);
  return 0;
}
```

**用指针作为函数返回值时需要注意的一点是，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误**。

### C语言二级指针

指针变量也是一种变量，也会占用存储空间，也可以使用`&`获取它的地址。C语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号`*`。p1 是一级指针，指向普通类型的数据，定义时有一个`*`；p2 是二级指针，指向一级指针 p1，定义时有两个`*`

```c
int a = 100;
int *pa = &a;
int **ppa = &pa;
int ***pppa = &ppa;

printf("%d,%d,%d,%d",a,*pa,**ppa,***pppa);//获取指针对应的数据
```

### C语言数组指针

如果一个数组中所有元素保存的都是指针，那么我们就称它为指针数组。

```c
datatype *arrayName[length];
```

[]的优先级高于\*，该定义形式应该理解为

```c
datatype *(arrayName[length]);
```

括号里面说明arrayName是一个数组，包含了length个元素，括号外面说明每个元素的类型为datatype\*。

```c
int pointerArray()
{
    int a = 16,b=932,c=100;
  	//数组指针
    int *arr[3] = {&a, &b, &c};
  	//二级指针，指向arr第0个元素的指针
    int **parr = &arr;
    //使用数组指针
    printf("%d, %d, %d\n",*arr[0], *arr[1], *arr[2]);
  	//使用二级指针
    printf("%d, %d, %d\n",**parr, **(parr+1), **(parr+2));
    return 0;
}
```

指针数组和字符串数组结合使用

```c
int pointerAndCharArray()
{
    char *msgs[3] = {"Hello World","This is me","c.biancheng.org"};
//    等价于下列形式
//    char *str1 = "Hello World";
//    char *str2 = "This is me";
//    char *str3 = "c.biancheng.org";
//    char *msgs[3]={str1, str2, str3};

    printf("%s\n%s\n%s\n", msgs[0],msgs[1],msgs[2]);
    return 0;
}
```

### 指针与二维数组

```c
//二维数组
int a[3][4] = {{0,1,2,3},{4,5,6,7},{8,9,10,11}};
```

a的分布是一维性的，整个二维数组占用一块连续的内存区域。

C语言允许把一个二维数组分解成多个一维数组来处理。对于数组a来说，它可以分解成三个一维数组a[0],a[1],a[2]。

```c
//指向a的指针变量p
int (*p)[4] = a;
```

\*表明p是一个指针，它指向一个数组a，数组的类型是int[4]，这正是a所包含的每个一维数组的类型。

**指针数组与数组指针的区别**

```c
int *p[4];//p为指针数组
int (*p1)[4];//p1为数组指针
```

### C语言函数指针（指向函数的指针）

**一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址。我们可以把函数的这个首地址赋予一个指针变量，是指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针**。

```c
returnType (*pointerName)(param list);
```

