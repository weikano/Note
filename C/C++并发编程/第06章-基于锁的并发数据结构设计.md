### 第06章-基于锁的并发数据结构设计

#### 6.1 并发性设计意义何在？

设计一个并发性的数据结构意味着多个线程可以并发的访问它。不管是进行怎样的操作，每一个线程都能在自己的自治域中看到它，并且在多线程的环境不会造成数据丢失和损坏。这样的数据结构被称为线程安全的。

通过互斥量来实现的数据结构，一般是类似串行：每个线程轮流来访问数据。

##### 6.1.1 数据结构并发设计指南

从两方面考虑：

1. 确保数据访问是安全的
2. 能够真正的并发访问

最简单的实现方式是通过互斥量和锁来对数据进行保护。这样做能保证同一时间只有一个线程能对数据进行访问。

#### 6.2 基于锁的并发数据结构

##### 6.2.1 线程安全栈-使用锁

代码参考第03章的threadsafe_stack实现

##### 6.2.2 线程安全队列-使用锁和条件变量

代码参考第04章中的threadsafe_queue，只需要将push操作的notify_one改成notify_all，这样可以避免被唤醒的线程在wait_and_pop出现异常时，其他线程也无法唤醒的情况

##### 6.2.3 线程安全队列-使用细粒度锁和条件变量

#### 6.3 基于锁设计更加复杂的数据结构

##### 6.3.1 编写一个使用锁的线程安全查询表（std::map）

##### 6.3.2 编写一个使用锁的线程安全链表



