### 一、指针和内存
C程序在编译后，会以三种形式使用内存
- 静态/全局内存：静态声明的变量分配在此，全局变量也使用这部分内存。这些变量在程序开始时分配，知道程序终止时才消失。所有函数都能访问全局变量，**静态变量的作用域则局限在定义它们的函数内部**
- 自动内存：函数内部声明的变量，仅在函数调用时创建。作用域仅限于函数内部，生命周期则为函数执行时间内。
- 动态内存：分配在堆上，可根据需要释放，知道释放才消失。

#### 1. 为什么要精通指针
指针有几种用途：
- 写出高效代码
- 为解决很多类问题提供方便的途径
- 动态分配内存(malloc和free)
- 使表达式变得紧凑和简洁
- 提供用指针传递数据结构的能力而不会带来庞大的开销
- 保护作为参数传递给函数的数据

#### 2. 声明指针
```C
int num;
int *pi;
//pi的内容最终应该指向一个赋值为整数变量的地址
//这些变量没有初始化，所以包含的是垃圾数据
//指针有类型
```

#### 3. 如何阅读声明
```C
const int *pci;
//1.pci是一个变量 pci
//2.pci是一个指针变量 *pci
//3.pci是一个指向整数的指针变量 int *pci
//4.pci是一个指向整数常亮的指针变量 const int *pci
```

#### 4. 地址操作符
```C
int num=0;
int *pi=&num;
//假设num的内存地址是100，pi的内存单元是104，那么pi在104中保存的是100，即num的地址
```

#### 5. 打印指针的值
```C
int num = 0;
int *pi = &num;
cout<<&num<<" with value "<<num<<endl;
cout<<&pi<<" with value"<<pi<<endl;
//结果如下
//0x7ffc7449ab54 with value 0
//0x7ffc7449ab58 with value 0x7ffc7449ab54
```

#### 6. 用间接引用操作符解引指针
```C
int num=5;
int *pi = &num;
int value = *pi;
//value值为5
×pi=200;
//num的值同时修改为200
```

#### 7. 指向函数的指针
#### 8. null的概念
- void指针：通用指针，可以存放任何数据类型的引用。void指针具有与char指针相同的形式和内存对齐方式；void指针和别的指针永远不相等，不过两个赋值为NULL的void指针是相等的。
- 全局和静态指针：程序启动时会被初始化为NULL

### 二、指针的长度和类型
#### 1. 内存模型
#### 指针相关的预定义类型
- size_t：用于表示长度
- ptrdiff_t：用于处理指针算术运算
- intptr_t和uintptr_t：用于存储指针地址

### 三、指针操作符
#### 1. 指针算术运算
- 给指针加上/减去整数
```C
int vector[] = {28,41,7};
int *pi = vector;
printf("%d\n", *pi);//28
printf("%d\n", pi);//假设内存地址是100
pi+=1;
print("%d\n",*pi)//41，指向vector中的第二个元素;
print("%d\n", pi)//104, 100+sizeof(int)=100+4=104
```
- 两个指针相减
```C
int vector[] = {28,41,7};
int *p0 = vector;
int *p1= vector+1;
int *p2= vector+2;

p2-p0==2;
p2-p1==1;
```
- 比较指针：一般用来判断数组中元素的相对顺序

### 四、指针的常见用法
#### 1. 多层间接引用
#### 2. 常亮与指针
```C
int num=5;
const int limit = 500;
int *pi=&num;
const int *pci=&limit;//可以看做(const int) *pci，即pci是一个指向整形常亮的指针

*pci=200;//报错，不能通过解引用修改指向const int的值
pci=&num;//可以修改pci指向的变量的地址来修改pci代表的值
```