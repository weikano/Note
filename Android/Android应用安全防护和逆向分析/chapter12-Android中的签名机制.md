### 一、基本概念
#### 1.数据摘要
> 对原始数据进行某种形式的数据提取，提取出的信息就是数据摘要，可以看做hash算法
> - 无论原始信息有多长，计算出来的摘要数据长度是固定的
> - 摘要算法是不可逆的
> - 不考虑碰撞的情况下，不同的原始数据有不同的数据摘要

#### 2.签名文件和证书
二者成对出现不可分离，并且二者的文件名字一样，只是扩展名不一样。
数字签名要确保通信可靠：必须保证数据不被篡改、消息来源确实是申明的那个人。
对于消息发送者来说，先要生成一对公私钥（非对称加密）
> 非对称加密：公钥和私钥是一对。如果用公钥加密，只有用对应的私钥才能解密；用私钥加密，只有用对应的公钥才能解密。

发送者向接收者发送消息：
1. 对于要发送的消息提取数据摘要
2. 对数据摘要使用私钥加密
3. 发送消息和加密后的数据摘要

接收者：
1. 对原始消息提取摘要
2. 对接收的摘要使用公钥进行解密
3. 比较前两步的值是否一致。如果不相等，代表数据被篡改或者不是同一个发送者。

**综上所述，数字签名是只有消息的发送者才能产生的别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明**

**上述结论有一个前提：接收者拿到的公钥是正确的**。
保证公钥的正确，需要数字证书来解决。

数字证书包含以下内容：
- 颁发机构
- 有效期
- 消息发送方的公钥
- 证书所有者
- 数字签名使用的算法
- 数字签名

#### 3. jarsign和signapk工具
- jarsign是jdk自带的工具，用来签名jar
- signapk是专门为了apk签名的工具，签名算法没什么区别

#### 4. keystore文件和pk8、x509.pem的却别
- jarsign使用keystore文件
- signapk使用pk8、x509.pem

### 二、Android中的签名流程
signapk的源码位置在com/android/signapk/sign.java
1. MANIFEST.MF文件
> apk中所有文件的数据摘要
2. CERT.SF文件
> MANIFEST.SF文件中每个块内容的数据摘要。计算MANIFEST.MF文件的整体SHA1值，再经过BASE64编码后放到CERT.SF主属性快（文件头上）的"SHA1-Digest-Manifest"中，然后逐条计算MANIFEST.MF中的每个块的SHA1再BASE64编码后，记录在CERT.SF的同名块中，属性的名字是"SHA1-Digest"。
3. CERT.RSA文件
> 对签名的CERT.SF文件做签名操作之后的结果。

### 三、为何采用这种签名机制
略